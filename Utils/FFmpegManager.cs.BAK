using System;
using System.IO;
using System.Net.Http;
using System.Threading.Tasks;
using System.IO.Compression;
using System.Diagnostics;
using System.Runtime.InteropServices;
using LuckyStars.Core;

namespace LuckyStars.Utils
{
    /// <summary>
    /// FFmpeg管理器，负责FFmpeg的版本管理和运行环境配置
    /// </summary>
    public class FFmpegManager
    {
        // FFmpeg资源文件夹路径
        private readonly string _ffmpegFolder;
        
        // FFmpeg可执行文件路径
        private string _ffmpegExePath;
        private string _ffprobePath;
        
        // FFmpeg版本信息
        private string _version = string.Empty;
        
        // 日志记录器
        private readonly FFmpegLogger _logger;

        // FFmpeg下载地址（GitHub发布地址）
        private const string FFmpegDownloadBaseUrl = "https://github.com/BtbN/FFmpeg-Builds/releases/download/latest/";
        
        // 不同平台的FFmpeg文件名
        private const string WindowsFFmpegFileName = "ffmpeg-master-latest-win64-gpl.zip";
        
        /// <summary>
        /// 获取FFmpeg可执行文件的路径
        /// </summary>
        public string FFmpegPath => _ffmpegExePath;
        
        /// <summary>
        /// 获取FFprobe可执行文件的路径
        /// </summary>
        public string FFprobePath => _ffprobePath;
        
        /// <summary>
        /// 获取FFmpeg版本
        /// </summary>
        public string Version => _version;

        /// <summary>
        /// 初始化FFmpeg管理器
        /// </summary>
        /// <param name="appDataFolder">应用数据文件夹路径</param>
        public FFmpegManager(string appDataFolder)
        {
            _ffmpegFolder = Path.Combine(appDataFolder, "FFmpeg");
            _logger = new FFmpegLogger(Path.Combine(appDataFolder, "Logs"));
            
            // 确保目录存在
            Directory.CreateDirectory(_ffmpegFolder);
            
            // 初始化FFmpeg路径
            InitializePaths();
        }

        /// <summary>
        /// 初始化FFmpeg路径
        /// </summary>
        private void InitializePaths()
        {
            string binFolder = Path.Combine(_ffmpegFolder, "bin");
            
            if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
            {
                _ffmpegExePath = Path.Combine(binFolder, "ffmpeg.exe");
                _ffprobePath = Path.Combine(binFolder, "ffprobe.exe");
            }
            else
            {
                _ffmpegExePath = Path.Combine(binFolder, "ffmpeg");
                _ffprobePath = Path.Combine(binFolder, "ffprobe");
            }
        }

        /// <summary>
        /// 确保FFmpeg已安装，如果未安装则尝试安装
        /// </summary>
        /// <returns>异步任务，安装成功返回true</returns>
        public async Task<bool> EnsureFFmpegInstalledAsync()
        {
            try
            {
                // 检查FFmpeg是否已经安装
                if (IsFFmpegInstalled())
                {
                    await UpdateVersionInfoAsync();
                    _logger.Log($"FFmpeg已安装，版本: {_version}");
                    return true;
                }

                _logger.Log("FFmpeg未安装，开始下载安装...");
                
                // 首先尝试从内置资源中提取
                if (await ExtractEmbeddedFFmpegAsync())
                {
                    _logger.Log("从内置资源中提取FFmpeg成功");
                    await UpdateVersionInfoAsync();
                    return true;
                }

                // 如果内置资源提取失败，尝试从网络下载
                _logger.Log("内置资源提取失败，尝试从网络下载...");
                if (await DownloadFFmpegAsync())
                {
                    _logger.Log("从网络下载FFmpeg成功");
                    await UpdateVersionInfoAsync();
                    return true;
                }

                _logger.Log("FFmpeg安装失败");
                return false;
            }
            catch (Exception ex)
            {
                _logger.Log($"确保FFmpeg安装时出错: {ex.Message}");
                return false;
            }
        }

        /// <summary>
        /// 检查FFmpeg是否已安装
        /// </summary>
        /// <returns>如果已安装返回true</returns>
        private bool IsFFmpegInstalled()
        {
            return File.Exists(_ffmpegExePath) && File.Exists(_ffprobePath);
        }

        /// <summary>
        /// 从内置资源中提取FFmpeg
        /// </summary>
        /// <returns>异步任务，成功返回true</returns>
        private async Task<bool> ExtractEmbeddedFFmpegAsync()
        {
            try
            {
                // 尝试查找内置资源
                string embeddedPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Resources", "FFmpeg");
                
                if (Directory.Exists(embeddedPath))
                {
                    _logger.Log($"找到内置FFmpeg资源: {embeddedPath}");
                    
                    // 复制FFmpeg文件到应用数据文件夹
                    string binFolder = Path.Combine(_ffmpegFolder, "bin");
                    Directory.CreateDirectory(binFolder);
                    
                    foreach (string file in Directory.GetFiles(Path.Combine(embeddedPath, "bin")))
                    {
                        string destFile = Path.Combine(binFolder, Path.GetFileName(file));
                        File.Copy(file, destFile, true);
                    }
                    
                    _logger.Log("成功从内置资源提取FFmpeg");
                    return true;
                }
                
                _logger.Log("未找到内置FFmpeg资源");
                return false;
            }
            catch (Exception ex)
            {
                _logger.Log($"从内置资源提取FFmpeg失败: {ex.Message}");
                return false;
            }
        }

        /// <summary>
        /// 从网络下载FFmpeg
        /// </summary>
        /// <returns>异步任务，成功返回true</returns>
        private async Task<bool> DownloadFFmpegAsync()
        {
            try
            {
                // 确定下载文件名
                string downloadFileName = WindowsFFmpegFileName; // 当前仅支持Windows
                
                // 下载地址
                string downloadUrl = FFmpegDownloadBaseUrl + downloadFileName;
                
                _logger.Log($"开始下载FFmpeg: {downloadUrl}");
                
                // 临时下载文件路径
                string tempFilePath = Path.Combine(_ffmpegFolder, downloadFileName);
                
                // 下载FFmpeg
                using (HttpClient client = new HttpClient())
                {
                    // 设置超时时间 (15分钟)
                    client.Timeout = TimeSpan.FromMinutes(15);
                    
                    // 下载文件
                    var response = await client.GetAsync(downloadUrl);
                    response.EnsureSuccessStatusCode();
                    
                    using (var fileStream = new FileStream(tempFilePath, FileMode.Create, FileAccess.Write))
                    {
                        await response.Content.CopyToAsync(fileStream);
                    }
                }
                
                _logger.Log($"成功下载FFmpeg到: {tempFilePath}");
                
                // 解压FFmpeg
                _logger.Log("开始解压FFmpeg...");
                string extractFolder = Path.Combine(_ffmpegFolder, "extract");
                
                // 确保提取目录存在并为空
                if (Directory.Exists(extractFolder))
                {
                    Directory.Delete(extractFolder, true);
                }
                Directory.CreateDirectory(extractFolder);
                
                // 解压文件
                ZipFile.ExtractToDirectory(tempFilePath, extractFolder);
                
                // 查找解压后的bin目录
                string extractedBinPath = null;
                foreach (var dir in Directory.GetDirectories(extractFolder))
                {
                    foreach (var subDir in Directory.GetDirectories(dir))
                    {
                        if (Path.GetFileName(subDir).ToLower() == "bin")
                        {
                            extractedBinPath = subDir;
                            break;
                        }
                    }
                    if (extractedBinPath != null) break;
                }
                
                if (extractedBinPath == null)
                {
                    _logger.Log("在解压后的文件中未找到bin目录");
                    return false;
                }
                
                _logger.Log($"找到bin目录: {extractedBinPath}");
                
                // 复制FFmpeg文件到应用数据文件夹
                string binFolder = Path.Combine(_ffmpegFolder, "bin");
                Directory.CreateDirectory(binFolder);
                
                foreach (string file in Directory.GetFiles(extractedBinPath))
                {
                    string destFile = Path.Combine(binFolder, Path.GetFileName(file));
                    File.Copy(file, destFile, true);
                }
                
                _logger.Log("成功安装FFmpeg");
                
                // 清理临时文件
                try
                {
                    File.Delete(tempFilePath);
                    Directory.Delete(extractFolder, true);
                }
                catch
                {
                    // 忽略清理错误
                }
                
                return true;
            }
            catch (Exception ex)
            {
                _logger.Log($"下载FFmpeg失败: {ex.Message}");
                return false;
            }
        }

        /// <summary>
        /// 更新FFmpeg版本信息
        /// </summary>
        /// <returns>异步任务</returns>
        private async Task UpdateVersionInfoAsync()
        {
            try
            {
                // 使用FFmpeg -version命令获取版本信息
                if (File.Exists(_ffmpegExePath))
                {
                    ProcessStartInfo psi = new ProcessStartInfo
                    {
                        FileName = _ffmpegExePath,
                        Arguments = "-version",
                        RedirectStandardOutput = true,
                        UseShellExecute = false,
                        CreateNoWindow = true
                    };
                    
                    using (Process process = Process.Start(psi))
                    {
                        string output = await process.StandardOutput.ReadToEndAsync();
                        process.WaitForExit();
                        
                        // 提取版本号
                        if (!string.IsNullOrEmpty(output))
                        {
                            int versionIndex = output.IndexOf("version");
                            if (versionIndex >= 0)
                            {
                                int startIndex = versionIndex + "version".Length;
                                int endIndex = output.IndexOf(' ', startIndex + 1);
                                if (endIndex > startIndex)
                                {
                                    _version = output.Substring(startIndex, endIndex - startIndex).Trim();
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.Log($"获取FFmpeg版本信息失败: {ex.Message}");
            }
        }

              /// <summary>
        /// 检查一个文件是否被FFmpeg支持
        /// </summary>
        /// <param name="filePath">文件路径</param>
        /// <returns>如果文件被FFmpeg支持则返回true</returns>
        public async Task<bool> IsFileSupported(string filePath)
        {
            try
            {
                if (!File.Exists(filePath))
                {
                    _logger.Log($"文件不存在: {filePath}");
                    return false;
                }

                // 确保FFmpeg已安装
                if (!await EnsureFFmpegInstalledAsync())
                {
                    _logger.Log("FFmpeg未安装，无法检查文件格式");
                    return false;
                }

                // 使用FFprobe检查文件格式
                ProcessStartInfo psi = new ProcessStartInfo
                {
                    FileName = _ffprobePath,
                    Arguments = $"-v error -show_entries format=format_name -of default=noprint_wrappers=1:nokey=1 \"{filePath}\"",
                    RedirectStandardOutput = true,
                    UseShellExecute = false,
                    CreateNoWindow = true
                };

                using (Process process = Process.Start(psi))
                {
                    string output = await process.StandardOutput.ReadToEndAsync();
                    process.WaitForExit();

                    // 如果有输出，说明文件格式被识别
                    return !string.IsNullOrEmpty(output.Trim());
                }
            }
            catch (Exception ex)
            {
                _logger.Log($"检查文件支持失败: {ex.Message}");
                return false;
            }
        }

        /// <summary>
        /// 获取媒体文件信息
        /// </summary>
        /// <param name="filePath">文件路径</param>
        /// <returns>媒体信息字典</returns>
        public async Task<Dictionary<string, string>> GetMediaInfoAsync(string filePath)
        {
            var mediaInfo = new Dictionary<string, string>();

            try
            {
                if (!File.Exists(filePath))
                {
                    _logger.Log($"文件不存在: {filePath}");
                    return mediaInfo;
                }

                // 确保FFmpeg已安装
                if (!await EnsureFFmpegInstalledAsync())
                {
                    _logger.Log("FFmpeg未安装，无法获取媒体信息");
                    return mediaInfo;
                }

                // 使用FFprobe获取媒体信息
                ProcessStartInfo psi = new ProcessStartInfo
                {
                    FileName = _ffprobePath,
                    Arguments = $"-v error -show_format -show_streams -of json \"{filePath}\"",
                    RedirectStandardOutput = true,
                    UseShellExecute = false,
                    CreateNoWindow = true
                };

                using (Process process = Process.Start(psi))
                {
                    string output = await process.StandardOutput.ReadToEndAsync();
                    process.WaitForExit();

                    if (!string.IsNullOrEmpty(output))
                    {
                        // 解析JSON输出
                        using (System.Text.Json.JsonDocument doc = System.Text.Json.JsonDocument.Parse(output))
                        {
                            // 提取格式信息
                            if (doc.RootElement.TryGetProperty("format", out var format))
                            {
                                foreach (var property in format.EnumerateObject())
                                {
                                    mediaInfo[$"format_{property.Name}"] = property.Value.ToString();
                                }
                            }

                            // 提取流信息
                            if (doc.RootElement.TryGetProperty("streams", out var streams))
                            {
                                for (int i = 0; i < streams.GetArrayLength(); i++)
                                {
                                    var stream = streams[i];
                                    string codecType = stream.GetProperty("codec_type").GetString();
                                    
                                    // 提取视频和音频流的基本信息
                                    if (codecType == "video" || codecType == "audio")
                                    {
                                        foreach (var property in stream.EnumerateObject())
                                        {
                                            mediaInfo[$"{codecType}{i}_{property.Name}"] = property.Value.ToString();
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.Log($"获取媒体信息失败: {ex.Message}");
            }

            return mediaInfo;
        }

        /// <summary>
        /// 检查FFmpeg是否支持硬件加速
        /// </summary>
        /// <returns>支持的硬件加速方法列表</returns>
        public async Task<List<string>> GetSupportedHardwareAccelerationMethodsAsync()
        {
            List<string> supportedMethods = new List<string>();

            try
            {
                // 确保FFmpeg已安装
                if (!await EnsureFFmpegInstalledAsync())
                {
                    _logger.Log("FFmpeg未安装，无法检查硬件加速支持");
                    return supportedMethods;
                }

                // 检查支持的硬件加速方法
                ProcessStartInfo psi = new ProcessStartInfo
                {
                    FileName = _ffmpegExePath,
                    Arguments = "-hwaccels",
                    RedirectStandardOutput = true,
                    UseShellExecute = false,
                    CreateNoWindow = true
                };

                using (Process process = Process.Start(psi))
                {
                    string output = await process.StandardOutput.ReadToEndAsync();
                    process.WaitForExit();

                    if (!string.IsNullOrEmpty(output))
                    {
                        // 解析输出，查找支持的硬件加速方法
                        string[] lines = output.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
                        bool started = false;

                        foreach (string line in lines)
                        {
                            if (started)
                            {
                                supportedMethods.Add(line.Trim());
                            }
                            else if (line.Contains("Hardware acceleration methods"))
                            {
                                started = true;
                            }
                        }
                    }
                }

                _logger.Log($"支持的硬件加速方法: {string.Join(", ", supportedMethods)}");
            }
            catch (Exception ex)
            {
                _logger.Log($"检查硬件加速支持失败: {ex.Message}");
            }

            return supportedMethods;
        }

        /// <summary>
        /// 异步执行FFmpeg命令
        /// </summary>
        /// <param name="arguments">命令参数</param>
        /// <param name="progressCallback">进度回调函数</param>
        /// <param name="cancellationToken">取消令牌</param>
        /// <returns>执行是否成功</returns>
        public async Task<bool> ExecuteCommandAsync(
            string arguments,
            Action<double> progressCallback = null,
            System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                // 确保FFmpeg已安装
                if (!await EnsureFFmpegInstalledAsync())
                {
                    _logger.Log("FFmpeg未安装，无法执行命令");
                    return false;
                }

                _logger.Log($"执行FFmpeg命令: {arguments}");

                // 准备进程信息
                ProcessStartInfo psi = new ProcessStartInfo
                {
                    FileName = _ffmpegExePath,
                    Arguments = arguments + " -progress pipe:1",
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    UseShellExecute = false,
                    CreateNoWindow = true
                };

                // 启动进程
                using (Process process = new Process())
                {
                    process.StartInfo = psi;
                    process.EnableRaisingEvents = true;

                    // 存储总时长和当前进度
                    TimeSpan totalDuration = TimeSpan.Zero;
                    TimeSpan currentTime = TimeSpan.Zero;

                    // 处理标准错误输出，用于提取总时长
                    process.ErrorDataReceived += (sender, e) =>
                    {
                        if (!string.IsNullOrEmpty(e.Data))
                        {
                            _logger.Log($"FFmpeg: {e.Data}");
                            
                            // 尝试从输出中提取总时长
                            if (e.Data.Contains("Duration:"))
                            {
                                int start = e.Data.IndexOf("Duration:") + "Duration:".Length;
                                int end = e.Data.IndexOf(",", start);
                                if (end > start)
                                {
                                    string durationStr = e.Data.Substring(start, end - start).Trim();
                                    if (TimeSpan.TryParse(durationStr, out TimeSpan duration))
                                    {
                                        totalDuration = duration;
                                    }
                                }
                            }
                        }
                    };

                    // 处理标准输出，用于解析进度
                    process.OutputDataReceived += (sender, e) =>
                    {
                        if (!string.IsNullOrEmpty(e.Data))
                        {
                            // 解析进度信息
                            if (e.Data.StartsWith("out_time="))
                            {
                                string timeStr = e.Data.Substring("out_time=".Length).Trim();
                                if (TimeSpan.TryParse(timeStr, out TimeSpan time))
                                {
                                    currentTime = time;
                                    
                                    // 计算并报告进度
                                    if (totalDuration.TotalSeconds > 0 && progressCallback != null)
                                    {
                                        double progress = currentTime.TotalSeconds / totalDuration.TotalSeconds;
                                        progressCallback(Math.Min(1.0, Math.Max(0.0, progress)));
                                    }
                                }
                            }
                        }
                    };

                    // 启动进程并开始异步读取输出
                    process.Start();
                    process.BeginErrorReadLine();
                    process.BeginOutputReadLine();

                    // 等待进程完成或取消
                    while (!process.HasExited)
                    {
                        await Task.Delay(100);
                        
                        // 检查是否请求取消
                        if (cancellationToken.IsCancellationRequested)
                        {
                            try
                            {
                                process.Kill();
                                _logger.Log("FFmpeg命令已取消");
                                return false;
                            }
                            catch (Exception ex)
                            {
                                _logger.Log($"取消FFmpeg命令失败: {ex.Message}");
                            }
                        }
                    }

                    // 检查进程退出代码
                    bool success = process.ExitCode == 0;
                    _logger.Log($"FFmpeg命令完成，退出代码: {process.ExitCode}, 成功: {success}");
                    
                    // 确保进度回调执行到100%
                    if (success && progressCallback != null)
                    {
                        progressCallback(1.0);
                    }
                    
                    return success;
                }
            }
            catch (Exception ex)
            {
                _logger.Log($"执行FFmpeg命令失败: {ex.Message}");
                return false;
            }
        }

        /// <summary>
        /// 获取视频缩略图
        /// </summary>
        /// <param name="videoPath">视频文件路径</param>
        /// <param name="outputPath">输出缩略图路径</param>
        /// <param name="timePosition">时间位置（秒）</param>
        /// <param name="width">缩略图宽度，0表示保持原比例</param>
        /// <param name="height">缩略图高度，0表示保持原比例</param>
        /// <returns>是否成功获取缩略图</returns>
        public async Task<bool> GenerateThumbnailAsync(string videoPath, string outputPath, double timePosition = 5.0, int width = 0, int height = 0)
        {
            try
            {
                // 确保FFmpeg已安装
                if (!await EnsureFFmpegInstalledAsync())
                {
                    _logger.Log("FFmpeg未安装，无法生成缩略图");
                    return false;
                }

                // 构建缩放参数
                string scaleParam = "";
                if (width > 0 && height > 0)
                {
                    scaleParam = $"-s {width}x{height}";
                }
                else if (width > 0)
                {
                    scaleParam = $"-vf scale={width}:-1";
                }
                else if (height > 0)
                {
                    scaleParam = $"-vf scale=-1:{height}";
                }

                // 构建命令参数
                string arguments = $"-ss {timePosition} -i \"{videoPath}\" -frames:v 1 {scaleParam} -y \"{outputPath}\"";
                
                // 执行命令
                return await ExecuteCommandAsync(arguments);
            }
            catch (Exception ex)
            {
                _logger.Log($"生成视频缩略图失败: {ex.Message}");
                return false;
            }
        }

        /// <summary>
        /// 清理临时文件和日志
        /// </summary>
        public void Cleanup()
        {
            try
            {
                // 清理临时文件
                string[] tempFiles = Directory.GetFiles(_ffmpegFolder, "*.tmp");
                foreach (string file in tempFiles)
                {
                    try
                    {
                        File.Delete(file);
                    }
                    catch 
                    { 
                        // 忽略删除错误
                    }
                }

                // 清理旧日志
                _logger.CleanupOldLogs();
            }
            catch (Exception ex)
            {
                _logger.Log($"清理临时文件失败: {ex.Message}");
            }
        }
    }
}
        